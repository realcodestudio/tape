<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BS-Tape</title>
  <style>
    :root {
      --bg: #0b0f19;
      --panel: #121826;
      --panel-2: #0e1422;
      --accent: #56ccf2;
      --accent-2: #2f80ed;
      --danger: #ff5f6d;
      --ok: #4cd137;
      --warn: #f5a623;
      --text: #e6eefc;
      --muted: #9fb3d0;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 10% 0%, #0f162c, #0a0f1d 60%, #070b14 100%);
      color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "Helvetica Neue", Arial, "Microsoft YaHei", sans-serif;
    }

    /* Header */
    .header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 20px; gap: 16px;
    }
    .brand {
      display: flex; align-items: center; gap: 12px; letter-spacing: .5px;
    }
    .brand-badge {
      padding: 6px 10px; border-radius: 8px; font-weight: 600; font-size: 14px;
      color: #0c1220; background: linear-gradient(135deg, var(--accent), var(--accent-2));
      box-shadow: 0 4px 20px rgba(47,128,237,.35);
    }
    .brand-title { font-size: 18px; color: var(--text); opacity: .9; }

    .status {
      display: flex; align-items: center; gap: 10px; font-size: 14px; color: var(--muted);
    }
    .dot {
      width: 10px; height: 10px; border-radius: 50%;
      box-shadow: 0 0 10px rgba(76, 209, 55, .7);
      background: var(--ok);
      transition: background .25s ease, box-shadow .25s ease;
    }
    .dot.warn { background: var(--warn); box-shadow: 0 0 10px rgba(245, 166, 35, .7); }
    .dot.err { background: var(--danger); box-shadow: 0 0 10px rgba(255, 95, 109, .7); }
    
    /* 震度样式 - JMA信息上实际使用的震度系统 */
    .intensity-level { 
      display: inline-block; 
      padding: 2px 11px; 
      border-radius: 100px; 
      font-weight: bold; 
      color: white; 
      margin: 0 2px; 
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .intensity-level-1 { background-color: #7e7e7e; } /* 震度1  */
    .intensity-level-2 { background-color: #1465fd; } /* 震度2  */
    .intensity-level-3 { background-color: #15d603; } /* 震度3  */
    .intensity-level-4 { background-color: #cfc507; } /* 震度4  */
    .intensity-level-5 { background-color: #ffb428; } /* 震度5弱  */
    .intensity-level-6 { background-color: #ff8800; } /* 震度5强 */
    .intensity-level-7 { background-color: #e5628e; } /* 震度6弱 */
    .intensity-level-8 { background-color: #b61111; } /* 震度6强 */
    .intensity-level-9 { background-color: #9a04a8; } /* 震度7 */
    
    
  
    /* 中国烈度样式 - 12级烈度系统 */
    .intensity-level-cn-1 { background-color: #7e7e7e; } /* 烈度1 */
    .intensity-level-cn-2 { background-color: #1465fd; } /* 烈度2 */
    .intensity-level-cn-3 { background-color: #15d603; } /* 烈度3 */
    .intensity-level-cn-4 { background-color: #cfc507; } /* 烈度4 */
    .intensity-level-cn-5 { background-color: #ffb428; } /* 烈度5 */
    .intensity-level-cn-6 { background-color: #ff8800; } /* 烈度6 */
    .intensity-level-cn-7 { background-color: #e5628e; } /* 烈度7 */
    .intensity-level-cn-8 { background-color: #b61111; } /* 烈度8 */
    .intensity-level-cn-9 { background-color: #df7fe7; } /* 烈度9 */
    .intensity-level-cn-10 { background-color: #d05bf0; } /* 烈度10 */
    .intensity-level-cn-11 { background-color: #c843e0; } /* 烈度11 */
    .intensity-level-cn-12 { background-color: #9600b5; } /* 烈度12 */

    /* Content card */rgb(90, 11, 106)
    .card {
      max-width: 980px; margin: 40px auto 120px; padding: 20px 22px;
      border-radius: 16px; background:
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)),
        linear-gradient(180deg, rgba(86, 204, 242, .08), rgba(47,128,237,.05));
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .card h2 { margin: 0 0 8px; font-size: 22px; }
    .meta { display: flex; gap: 14px; color: var(--muted); font-size: 14px; }

    /* Ticker */
    .ticker {
      position: fixed; left: 0; right: 0; bottom: 0; height: 64px; z-index: 999;
      background:
        linear-gradient(0deg, rgba(255,255,255,.04), rgba(255,255,255,0)),
        linear-gradient(90deg, rgba(47,128,237,.14), rgba(86,204,242,.14));
      border-top: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 -8px 30px rgba(0,0,0,.35);
      display: grid; grid-template-columns: auto 1fr; align-items: center;
    }
    .ticker-label {
      height: 64px; display: flex; align-items: center; padding: 0 18px; gap: 10px;
      font-weight: 750; color: #000000; text-transform: uppercase; letter-spacing: .10px; /* 文字颜色大小间距 */
      background: linear-gradient(135deg, #98d0f8, #0180ff);  /* 自定义颜色左框 */
      box-shadow: inset 0 -2px 0 rgba(255,255,255,.25), 0 0 24px rgba(117, 209, 255, 0.35);
    }
    #tickerLabelText, #networkTime {
      font-size: clamp(16px, 4vw, 32px); /* 响应式字体：最小值16px，基于视口宽度4%，最大值32px */
    }
    .ticker-label .live-dot {
      width: 10px; height: 10px; border-radius: 50%; background: #fff; box-shadow: 0 0 10px #fff;
      animation: pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse { 0%,100% { transform: scale(1); opacity: 1 } 50% { transform: scale(0.6); opacity: .6 } }

    .ticker-rail { position: relative; overflow: hidden; }
    .ticker-track {
      display: inline-block; white-space: nowrap; will-change: transform;
      animation: scroll 25s linear infinite;
      padding-left: 100%; /* start from right outside */
    }
    .ticker-text { display: inline-block; padding: 0 30px; font-size: 40px; /* 固定字体大小40px，可根据需要修改 */ color: var(--text); text-shadow: 0 2px 8px rgba(0,0,0,.5); }
    .sep { color: rgba(255,255,255,.35); padding: 0 22px; }
    @keyframes scroll { 0% { transform: translate3d(0,0,0) } 100% { transform: translate3d(-100%,0,0) } }

    /* Small helpers */
    .badge {
      display: inline-flex; align-items: center; gap: 6px; font-size: 13px;
      color: var(--text); background: rgba(47,128,237,.18); border: 1px solid rgba(86,204,242,.35);
      padding: 6px 10px; border-radius: 999px;
    }
    /* Overlay-only ticker mode */
    html, body { background: transparent !important; }
    body { background-color: transparent !important; }
    .header, .card { display: none !important; }
  </style>
</head>
<body>
  <header class="header">
    <div class="brand">
      <div class="brand-badge">JMA Live</div>
      <div class="brand-title">最新地震情報（No1）</div>
      <span class="badge" id="intensityBadge" aria-live="polite">最大震度: -</span>
    </div>
    <div class="status">
      <div class="dot" id="connDot" aria-hidden="true"></div>
      <span id="connText">接続中…</span>
    </div>
  </header>

  <main class="card">
    <h2 id="headline">最新地震テロップ（テレビ下部の走行表示）</h2>
    <div class="meta">
      <div>時刻: <span id="eventTime">—</span></div>
      <div>地点: <span id="eventLoc">—</span></div>
      <div>M: <span id="eventMag">—</span></div>
      <div>深さ: <span id="eventDepth">—</span></div>
      <div>ID: <span id="eventId">—</span></div>
    </div>
    
    <!-- 自定义栏目 -->
    <div style="margin-top: 20px; padding: 15px; background-color: rgba(255,255,255,0.05); border-radius: 8px;">
      <h3 style="margin: 0 0 8px 0; font-size: 18px;">123</h3>
      <p style="margin: 0; color: var(--text);">ABCD</p>
    </div>
  </main>

  <!-- Bottom ticker -->
  <div class="ticker" role="region" aria-live="polite" aria-label="地震速報テロップ">
    <div class="ticker-label">
      <span id="tickerLabelText">地震信息</span>
      <span id="networkTime" style="margin-left: 20px; font-weight: normal;"></span>
    </div>
     <div class="ticker-rail">
       <div class="ticker-track" id="tickerTrack">
         <span class="ticker-text" id="tickerText">初始化中…正在获取最新地震信息</span>
         <span class="sep">•</span>
         <span class="ticker-text" id="tickerTextClone">初始化中…正在获取最新地震信息</span>
       </div>
     </div>
   </div>

  <script>
    // const WS_URL = 'wss://ws-api.wolfx.jp/jma_eqlist'; // 暂时注释WS
    const WEATHER_URL = 'https://api.wolfx.jp/weather_rank.json';
    const JMA_EQ_API = 'https://api.wolfx.jp/jma_eqlist.json';
    const CENC_EQ_API = 'https://api.wolfx.jp/cenc_eqlist.json';
    // let ws = null; // 暂时注释WS
    // let retryMs = 1200; // 暂时注释WS
    // const maxRetry = 30000; // 暂时注释WS
    let currentMode = 'eq'; // eq | temp | rain
    let lastNo1 = null;
    let lastCn1 = null;
    let currentTickerText = '';
    const weatherCache = { tsKey: null, tempRank: null, rainRank: null, fetchedAt: 0 };
    
    // Send command to request latest list from server
    // Fetch latest EQ list via HTTP API
    async function requestLatest() {
    try {
    const res = await fetch(JMA_EQ_API, { cache: 'no-store' });
    const json = await res.json();
    // Pick latest node if timestamp keys exist, else use root
    let node = json;
    const keys = Array.isArray(json) ? [] : Object.keys(json).filter(k => /^\d{12}$/.test(k));
    if (keys.length) {
    keys.sort((a,b) => Number(b) - Number(a));
    node = json[keys[0]] || {};
    }
    const latest = resolveLatest(node);
    if (latest) applyNo1(latest);
    } catch (e) {
    setStatus('error', '地震API获取失败');
    }
    }
    const el = {
      dot: document.getElementById('connDot'),
      text: document.getElementById('connText'),
      tickerText: document.getElementById('tickerText'),
      tickerTextClone: document.getElementById('tickerTextClone'),
      track: document.getElementById('tickerTrack'),
      time: document.getElementById('eventTime'),
      loc: document.getElementById('eventLoc'),
      mag: document.getElementById('eventMag'),
      depth: document.getElementById('eventDepth'),
      id: document.getElementById('eventId'),
      intensityBadge: document.getElementById('intensityBadge'),
      headline: document.getElementById('headline'),
      labelText: document.getElementById('tickerLabelText'),
      networkTime: document.getElementById('networkTime'),
     };
    
    // 网络时间相关变量
    let networkTimeOffset = 0; // 网络时间与本地时间的差值（毫秒）
    let lastSyncTime = 0; // 上次同步网络时间的时间戳
    const SYNC_INTERVAL = 5 * 60 * 1000; // 同步间隔：5分钟
    
    // 格式化时间为HH:MM:SS格式
    function formatTime(date) {
      return date.toLocaleTimeString('zh-CN', { 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit',
        hour12: false 
      });
    }
    
    // 更新显示的网络时间
    function updateNetworkTimeDisplay() {
      const now = new Date(Date.now() + networkTimeOffset);
      el.networkTime.textContent = formatTime(now);
    }
    
    // 尝试从多个API获取网络时间
    async function syncNetworkTime() {
      const apis = [
        { url: 'https://www.google.com', timeout: 2000 },
        { url: 'https://www.cloudflare.com', timeout: 2000 },
        { url: 'https://www.baidu.com', timeout: 2000 }
      ];
      
      for (const api of apis) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), api.timeout);
          
          const response = await fetch(api.url, {
            method: 'HEAD',
            cache: 'no-store',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          // 获取响应头中的Date字段
          const serverDate = response.headers.get('date');
          if (serverDate) {
            const serverTime = new Date(serverDate).getTime();
            const clientTime = Date.now();
            networkTimeOffset = serverTime - clientTime;
            lastSyncTime = clientTime;
            console.log('网络时间同步成功:', formatTime(new Date(serverTime)));
            return;
          }
        } catch (error) {
          console.log(`从${api.url}同步时间失败:`, error.message);
        }
      }
      
      // 如果所有API都失败，使用NTP方式
      try {
        // 使用公共NTP服务器的简化方法
        const response = await fetch('https://worldtimeapi.org/api/ip', {
          method: 'GET',
          cache: 'no-store'
        });
        
        if (response.ok) {
          const data = await response.json();
          const serverTime = new Date(data.utc_datetime).getTime();
          const clientTime = Date.now();
          networkTimeOffset = serverTime - clientTime;
          lastSyncTime = clientTime;
          console.log('通过worldtimeapi同步时间成功:', formatTime(new Date(serverTime)));
        }
      } catch (error) {
        console.log('NTP时间同步失败:', error.message);
      }
    }

    function setStatus(kind, msg) {
      el.dot.classList.remove('warn','err');
      if (kind === 'connected') {
        el.dot.classList.remove('warn','err');
        el.text.textContent = '接続済み';
      } else if (kind === 'reconnecting') {
        el.dot.classList.add('warn');
        el.text.textContent = '再接続中…';
      } else if (kind === 'error') {
        el.dot.classList.add('err');
        el.text.textContent = msg || '接続エラー';
      } else {
        el.text.textContent = msg || '接続中…';
      }
    }


    function connect() {
      try {
        ws = new WebSocket(WS_URL);
      } catch (e) {
        setStatus('error', 'WebSocket初期化失敗');
        scheduleReconnect();
        return;
      }

      ws.onopen = () => { setStatus('connected'); retryMs = 1200; requestLatest(); };

      ws.onmessage = (ev) => {
        let payload = null;
        try { payload = JSON.parse(ev.data); } catch (_) { return; }
        const latest = resolveLatest(payload);
        if (!latest) return;
        applyNo1(latest);
      };

      ws.onclose = () => { setStatus('reconnecting'); scheduleReconnect(); };
      ws.onerror = () => { setStatus('error'); try { ws.close(); } catch(_){} };
    }

    function scheduleReconnect() {
      setTimeout(() => connect(), retryMs);
      retryMs = Math.min(Math.floor(retryMs * 1.6), maxRetry);
    }

    // --- Rotation logic ---
    function setLabel(mode) {
      const map = { eq: '日本地震信息', cenc: '中国地震信息', temp: '气温排行', rain: '降雨排行', custom: '自定义栏目' }; //Labal设定 自定义
      el.labelText.textContent = map[mode] || '日本地震信息';
    }

    function setTickerText(text) {
      if (text !== currentTickerText) {
        currentTickerText = text;
        el.tickerText.innerHTML = text;
        el.tickerTextClone.innerHTML = text;
        
        // 保存当前滚动位置
        const currentPosition = parseFloat(getComputedStyle(el.track).transform.split(',')[4]) || 0;
        
        // 重置动画
        el.track.style.animation = 'none';
        void el.track.offsetWidth;
        
        // 重新开始动画
        el.track.style.transform = `translateX(${currentPosition}px)`;
        void el.track.offsetWidth;
        el.track.style.transform = '';
        el.track.style.animation = '';
        
        // 调整字体大小
        adjustTickerFontSize();
      }
    }

    async function fetchWeatherRank(force = false) {
      const ttlMs = 5 * 60 * 1000; // cache 5 minutes
      const now = Date.now();
      if (!force && weatherCache.fetchedAt && now - weatherCache.fetchedAt < ttlMs && weatherCache.tsKey) {
        return { tsKey: weatherCache.tsKey, tempRank: weatherCache.tempRank, rainRank: weatherCache.rainRank };
      }
      try {
        const res = await fetch(WEATHER_URL, { cache: 'no-store' });
        const json = await res.json();
        const keys = Object.keys(json).filter(k => /^\d{12}$/.test(k)).sort((a,b) => Number(b) - Number(a));
        const latestKey = keys[0];
        const node = json[latestKey] || {};
        weatherCache.tsKey = latestKey;
        weatherCache.tempRank = Array.isArray(node.tempRank) ? node.tempRank : [];
        weatherCache.rainRank = Array.isArray(node.rainRank) ? node.rainRank : [];
        weatherCache.fetchedAt = now;
        return { tsKey: latestKey, tempRank: weatherCache.tempRank, rainRank: weatherCache.rainRank };
      } catch (_) {
        return { tsKey: weatherCache.tsKey, tempRank: weatherCache.tempRank || [], rainRank: weatherCache.rainRank || [] };
      }
    }

    function buildTempText(list) {
      const arr = (list || []).slice(0, 10);
      if (!arr.length) return '中国气温排行：暂无数据';
      const items = arr.map((r,i) => `${i+1}. ${safe(r.province)}·${safe(r.city)} ${safe(r.value)}`);
      return `中国气温排行TOP${arr.length}：` + items.join(' ｜ ');
    }

    function buildRainText(list) {
      const arr = (list || []).slice(0, 10);
      if (!arr.length) return '中国降雨量排行：暂无数据';
      const items = arr.map((r,i) => `${i+1}. ${safe(r.province)}·${safe(r.city)} ${safe(r.value)}`);
      return `中国降雨量排行TOP${arr.length}：` + items.join(' ｜ ');
    }

    // 添加自定义内容模式
    function buildCustomText() {
      return 'TEST: 1234567890 - ABCDabcd - !@#$%^&, 1234567890 - ABCDabcd - !@#$%^&, 1234567890 - ABCDabcd - !@#$%^&, 你好，这是 BS Tape 测试, こんにちは、BS Tape テストです, Hi, this is BS Tape testing.';
    }

    async function setMode(mode) {
      currentMode = mode;
      setLabel(mode);
      if (mode === 'eq') {
        if (!lastNo1) {
          setTickerText('正在获取最新地震信息…');
          requestLatest();
        } else {
          setTickerText(buildTickerText(lastNo1));
        }
        return;
      }
      if (mode === 'cenc') {
        if (!lastCn1) {
          setTickerText('正在获取中国地震信息…');
          requestCencLatest();
        } else {
          setTickerText(buildCencText(lastCn1));
        }
        return;
      }
      if (mode === 'custom') {
        setTickerText(buildCustomText());
        return;
      }
      const data = await fetchWeatherRank();
      if (mode === 'temp') {
        setTickerText(buildTempText(data.tempRank));
      } else if (mode === 'rain') {
        setTickerText(buildRainText(data.rainRank));
      }
    }

    function isRecord(x) {
      return x && typeof x === 'object' && (
        'location' in x || 'magnitude' in x || 'shindo' in x || 'time' in x || 'time_full' in x
      );
    }

    function resolveLatest(node) {
      // Handle direct No1..NoN format
      if (node.No1 && isRecord(node.No1)) return node.No1;
      // Handle array of records (e.g. from WebSocket)
      if (Array.isArray(node)) return pickLatest(node.filter(isRecord));
      // Handle nested timestamp keys (e.g. weather API)
      const keys = Object.keys(node).filter(k => isRecord(node[k]));
      if (keys.length) return pickLatest(keys.map(k => node[k]));
      return null;
    }

    function pickLatest(list) {
      const parseTimeNum = (r) => {
        const t = r.time_full || r.time || '';
        const s = String(t).replace(/[^\d]/g, '');
        return s ? Number(s) : 0;
      };
      const parseEid = (r) => {
        const s = String(r.EventID || '').replace(/[^\d]/g, '');
        return s ? Number(s) : 0;
      };
      return list.slice().sort((a,b) => {
        const dt = parseTimeNum(b) - parseTimeNum(a);
        if (dt !== 0) return dt;
        return parseEid(b) - parseEid(a);
      })[0];
    }

    function buildTickerText(no1) {
      const shindo = safe(no1.shindo);
      const location = safe(no1.location);
      const magnitude = safe(no1.magnitude);
      const depth = safe(no1.depth);
      const time = safe(no1.time_full || no1.time);
      const info = (no1.info || '').trim();
      const parts = [
        `${time} | 最大震度 ${formatIntensity(shindo)} | ${location} |`,
        ` マグニチュード ${magnitude} |`,
        ` 深さ${depth} | `,
      ];
      if (info) parts.push(`${info}`);
      return parts.join('');
    }

    function safe(v) { return (v == null ? '-' : String(v)).trim(); }
    
    // 为震度/烈度数值添加带颜色背景的span标签
    function formatIntensity(value) {
      const valStr = String(value);
      let level;
      let isCencMode = currentMode === 'cenc';
      
      // 检查是否是中国烈度模式（当前模式为cenc或数值在1-12之间）
      const numValue = parseInt(valStr);
      if (isCencMode && !isNaN(numValue) && numValue >= 1 && numValue <= 12) {
        // 中国烈度系统：1-12级
        level = numValue;
        return `<span class="intensity-level intensity-level-cn-${level}">${value}</span>`;
      }
      
      // 日本震度系统处理
      switch (valStr) {
        case '1': level = 1; break;
        case '2': level = 2; break;
        case '3': level = 3; break;
        case '4': level = 4; break;
        case '5弱': level = 5; break;
        case '5強': level = 6; break;
        case '6弱': level = 7; break;
        case '6強': level = 8; break;
        case '7': level = 9; break;
        default:
          // 处理可能的变体（如只有数字）
          const match = valStr.match(/^(\d+)(弱|強)?$/);
          if (match) {
            const num = parseInt(match[1]);
            const suffix = match[2];
            
            if (num === 5 && suffix === '弱') level = 5;
            else if (num === 5 && suffix === '強') level = 6;
            else if (num === 6 && suffix === '弱') level = 7;
            else if (num === 6 && suffix === '強') level = 8;
            else if (num === 7) level = 9;
            else if (num >= 1 && num <= 4) level = num;
            else return value; // 无法识别的震度
          } else {
            // 尝试处理纯数字
            const num = parseInt(valStr);
            if (!isNaN(num) && num >= 1 && num <= 9) {
              level = num;
            } else {
              return value; // 无法识别的值
            }
          }
      }
      
      return `<span class="intensity-level intensity-level-${level}">${value}</span>`;
    }

    function applyNo1(no1) {
      lastNo1 = no1;
      if (currentMode === 'eq') {
        const text = buildTickerText(no1);
        setTickerText(text);
      }
 
       // Update meta card
       el.time.textContent = safe(no1.time_full || no1.time);
       el.loc.textContent = safe(no1.location);
       el.mag.textContent = safe(no1.magnitude);
       el.depth.textContent = safe(no1.depth);
       el.id.textContent = safe(no1.EventID || no1.eventId);
       el.intensityBadge.textContent = `最大震度: ${safe(no1.shindo)}`;
       el.headline.textContent = `最新: ${safe(no1.location)} / M${safe(no1.magnitude)} / 深さ ${safe(no1.depth)}`;
     }

    function buildCencText(no1) {
      const place = safe(no1.placeName || no1.location);
      const magnitude = safe(no1.magnitude);
      const depthRaw = safe(no1.depth);
      const depth = /^\d+(\.\d+)?$/.test(depthRaw) ? depthRaw + 'km' : depthRaw;
      const intensity = safe(no1.intensity);
      const time = safe(no1.time_full || no1.time);
      const info = [];
      if (no1.type) info.push(no1.type === 'reviewed' ? '正式报' : '自动报');
      const parts = [
        `${time} | 最大烈度${formatIntensity(intensity)} | `,
        `${place} |`,
        ` 震级 ${magnitude} |`,
        ` 深度${depth}`,
      ];
      if (info.length) parts.push(` | ${info.join(',')}`);
      return parts.join('');
    }

    async function requestCencLatest() {
      try {
        const res = await fetch(CENC_EQ_API, { cache: 'no-store' });
        const json = await res.json();
        const latest = resolveLatest(json);
        if (latest) applyCn1(latest);
      } catch (_) {}
    }

    function applyCn1(no1) {
      lastCn1 = no1;
      if (currentMode === 'cenc') {
        const text = buildCencText(no1);
        setTickerText(text);
      }
      // 更新信息卡（中国地震字段）
      el.time.textContent = safe(no1.time_full || no1.time);
      el.loc.textContent = safe(no1.placeName || no1.location);
      el.mag.textContent = safe(no1.magnitude);
      el.depth.textContent = safe(no1.depth);
      el.id.textContent = safe(no1.EventID || no1.eventId);
      el.intensityBadge.textContent = `最大烈度: ${safe(no1.intensity)}`;
      el.headline.textContent = `最新: ${safe(no1.placeName || no1.location)} / M${safe(no1.magnitude)} / 深度 ${safe(no1.depth)}`;
    }

    function getInitialMode() {
      const params = new URLSearchParams(location.search);
      const m = params.get('mode');
      const allowed = ['eq','cenc','temp','rain','custom'];
      return allowed.includes(m) ? m : 'eq';
    }

    function shouldRotate() {
      const params = new URLSearchParams(location.search);
      const r = params.get('rotate');
      if (r == null) return true;
      return ['1','true','yes','y','on'].includes(r.toLowerCase());
    }

    // 自动调整跑马灯字体大小的函数
    function adjustTickerFontSize() {
      // 调整跑马灯主体文字大小
      const tickerRailWidth = el.track.parentElement.clientWidth;
      const tickerTextWidth = el.tickerText.scrollWidth;
      const minFontSize = 12;
      const maxFontSize = 24;
      
      // 计算合适的字体大小
      let fontSize = maxFontSize;
      if (tickerTextWidth > tickerRailWidth * 2) {
        // 如果文本太长，按比例缩小字体
        fontSize = Math.max(minFontSize, Math.min(maxFontSize, (tickerRailWidth * 2 / tickerTextWidth) * maxFontSize));
      }
      
      // 应用计算出的字体大小
      el.tickerText.style.fontSize = `${fontSize}px`;
      el.tickerTextClone.style.fontSize = `${fontSize}px`;
      
      // 调整ticker-label中的文本大小
      const tickerLabelWidth = el.labelText.parentElement.clientWidth - 36; // 减去padding
      const labelTextWidth = el.labelText.scrollWidth;
      const networkTimeWidth = el.networkTime.scrollWidth;
      const totalLabelTextWidth = labelTextWidth + networkTimeWidth + 20; // 加20是margin-left
      
      // 如果文本总宽度超过容器宽度，需要缩小字体
      if (totalLabelTextWidth > tickerLabelWidth) {
        const scaleFactor = tickerLabelWidth / totalLabelTextWidth;
        const currentLabelFontSize = parseFloat(window.getComputedStyle(el.labelText).fontSize);
        const newLabelFontSize = Math.max(10, Math.min(16, currentLabelFontSize * scaleFactor * 0.9));
        
        el.labelText.style.fontSize = `${newLabelFontSize}px`;
        el.networkTime.style.fontSize = `${newLabelFontSize * 0.9}px`; // 时间稍小一点
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      el.text.textContent = 'HTTP轮询中';
      el.dot.classList.remove('warn','err');
      const initMode = getInitialMode();
      const rotate = shouldRotate();
      setMode(initMode);
      
      // 初始调整字体大小
      setTimeout(adjustTickerFontSize, 100);
      
      // 监听窗口大小变化
      window.addEventListener('resize', adjustTickerFontSize);
      
      // 初始化网络时间
      syncNetworkTime();
      // 每秒更新显示时间
      setInterval(updateNetworkTimeDisplay, 1000);
      // 定期同步网络时间
      setInterval(syncNetworkTime, SYNC_INTERVAL);
      // 立即更新一次显示
      updateNetworkTimeDisplay();
      if (rotate) {
        setInterval(async () => {
          const order = ['eq','cenc','custom','temp','rain'];
          const next = order[(order.indexOf(currentMode) + 1) % order.length];
          await setMode(next);
        }, 60 * 1000);
        // 轮播时两源都轮询
        setInterval(() => { requestLatest(); }, 5 * 1000);
        setInterval(() => { requestCencLatest(); }, 5 * 1000);
        requestLatest();
        requestCencLatest();
      } else {
        // 单项目显示时仅轮询对应来源
        if (initMode === 'eq') {
          requestLatest();
          setInterval(() => { requestLatest(); }, 5 * 1000);
        } else if (initMode === 'cenc') {
          requestCencLatest();
          setInterval(() => { requestCencLatest(); }, 5 * 1000);
        } else {
          // 其他模式仍可预取地震信息，避免后续切换时为空
          requestLatest();
          requestCencLatest();
        }
      }
    });

  </script>
</body>
</html>